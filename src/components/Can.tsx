/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import { useGLTF, useScroll } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useRef } from "react";
import { useFrame } from "@react-three/fiber";

type GLTFResult = GLTF & {
  nodes: {
    LowPoly__0: THREE.Mesh;
  };
  materials: {
    ["Scene_-_Root"]: THREE.MeshStandardMaterial;
  };
};

type CanProps = {
  canProps: JSX.IntrinsicElements["group"];
  canNumber: number;
};

export function Can({ canProps, canNumber }: CanProps) {
  const { nodes, materials } = useGLTF("/models/can.glb") as GLTFResult;
  const canRef = useRef<THREE.Group>(null!);

  const trigger = useRef(false);
  const finalPos = new THREE.Vector3(-0.15, -1, 0);
  const scrollData = useScroll();
  const initialQuaternion = new THREE.Quaternion().setFromEuler(
    new THREE.Euler(0, 0, 0)
  );
  const endQuaternion = new THREE.Quaternion().setFromEuler(
    new THREE.Euler(0, 2, -0.4)
  );

  useFrame((state, delta) => {
    const offset = scrollData.offset;
    if (!canRef.current) return;
    // hide can to top of screen and animate it down to mide
    if (canNumber === 1) {
      if (
        !trigger.current &&
        offset < 0.5 &&
        canRef.current.position.y < state.viewport.height / 1.3
      ) {
        canRef.current.position.y = state.viewport.height / 1.3;
        trigger.current = true;
      }
      // animation
      canRef.current.position.lerp(finalPos, delta > 0.1 ? 0.007 : delta);
    } else {
      if (!trigger.current) {
        canRef.current.position.x = state.viewport.width * 1.4;
        trigger.current = true;
      }
      if (offset < 0.8) {
        canRef.current.position.x = THREE.MathUtils.lerp(
          canRef.current.position.x,
          state.viewport.width * 1.4,
          delta > 0.1 ? 0.007 : delta * 0.7
        );
        canRef.current.quaternion.slerp(initialQuaternion, delta);
      } else {
        canRef.current.position.x = THREE.MathUtils.lerp(
          canRef.current.position.x,
          state.viewport.width * 0.25,
          delta > 0.1 ? 0.007 : delta
        );

        canRef.current.quaternion.slerp(endQuaternion, delta * 0.5);
      }
    }
  });

  return (
    <group ref={canRef} {...canProps} dispose={null}>
      <group rotation={[-Math.PI, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group rotation={[-Math.PI / 2, 0, 0]} scale={2.54}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.LowPoly__0.geometry}
              material={materials["Scene_-_Root"]}
              rotation={[Math.PI / 2, 0, 2.078]}
            />
          </group>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/models/can.glb");
